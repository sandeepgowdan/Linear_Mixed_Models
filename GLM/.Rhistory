# Extracting design matrix of fixed effects (Intercept and Genotype)
X <- model.matrix(formula(Fitted))
X <- X[!duplicated(X), ]
X
# Extracting the beta coefficients
Beta <- fixef(Fitted)
Beta
X <- X[!duplicated(X), ]
head(data)
# Extracting design matrix of fixed effects (Intercept and Genotype)
X <- model.matrix(formula(Fitted))
Fitted <- lmer(GY ~ GEN + (1|ENV), data = data)
# Extracting design matrix of fixed effects (Intercept and Genotype)
X <- model.matrix(formula(Fitted))
# Obtaining the BLUEs of genotypes
BLUEs_Gen <- X %*% Beta
BLUEs_Gen
# Estimating least square means by GEN
Lsmeans_Gen <- lsmeans(Fitted, ~ GEN)
str(Lsmeans_Gen)
# Creating the data frame of GEN and BLUEs
BLUEs_Gen1 <- data.frame(GID = levels(data$GEN),
BLUEs = summary(Lsmeans_Gen)$lsmean)
BLUEs_Gen1
# BLUP of genotypes
Fitted2 <- lmer(GY ~ (1|GEN) + (1|ENV) + (1|(GEN:ENV)))
# BLUP of genotypes
Fitted2 <- lmer(GY ~ (1|GEN) + (1|ENV) + (1|(GEN:ENV)), data = data)
Fitted2
# Fixed effect=Intercept
Intercept <- fixef(Fitted2)
str(Intercept)
U_ref <- c(ranef(Fitted2)$GEN)
U_ref
U_ref
# Fixed effect=Intercept
Intercept <- fixef(Fitted2)
str(Intercept)
U_ref <- c(ranef(Fitted2)$GEN)
U_ref
# BLUP of Genotypes
BLUP_Gen2 <- Intercept + U_ref$'(Intercept)'
BLUP_Gen2
cor(BLUEs_Gen, BLUP_Gen2)
# Creating a data frame of GEN and BLUPs
BLUPs_Gen1 <- data.frame(GID = levels(data$GEN),
BLUPs = BLUP_Gen2)
BLUPs_Gen1
# Creating a data frame of GEN, BLUEs, and BLUPs
Combined_Gen <- data.frame(
GID = levels(data$GEN),
BLUEs = BLUEs_Gen1$BLUEs,
BLUPs = BLUP_Gen2
)
# Writing combined data to CSV file
write.csv(Combined_Gen, file = "BLUEs_BLUPs_Gen.csv", row.names = FALSE)
###generating random numbers
# Syntax: runif(n, min = 0, max = 1)
# Generate 5 random numbers between 0 and 1
random_uniform <- runif(5, min = 0, max = 1)
print(random_uniform)
# Syntax: rnorm(n, mean = 0, sd = 1) ####
# Generate 5 random numbers from a normal distribution with mean 0 and standard deviation 1
random_normal <- rnorm(5, mean = 0, sd = 1)
print(random_normal)
# Syntax: sample(x, size, replace = FALSE, prob = NULL)
# Sample 3 values randomly from the vector
random_sample <- sample(c("A", "B", "C", "D", "E"), size = 3, replace = TRUE)
print(random_sample)
for (variable in sequence) {
# Code to be executed for each element
}
for (i in 1:5) {
square <- i^2
print(square)
}
for (i in 2:6) {
cube <- i^3
print(cube)
}
print(cube)
i <- 1
while (i^2 < 10) {
square <- i^2
print(square)
i <- i + 1
}
n <- 1
factorial_value <- 1
while (factorial_value <= 1000) {
factorial_value <- factorial_value * n
print(paste("Factorial of", n, "is", factorial_value))
n <- n + 1
}
number <- 1
while (number^2 <= 50) {
square_value <- number^2
print(paste("Square of", number, "is", square_value))
number <- number + 1
}
library(readr)
lentil_blocked <- read_csv("C:/Users/windows/OneDrive/Desktop/lentil_blocked.csv")
View(lentil_blocked)
### loops for dataframe
data <- lentil_blocked
# Create a new column 'PRODUCT' to store the results
data$results <- numeric(nrow(data))
data
data$results[i] <- data$YIELD[i] * data$NITROGEN[i]
# Using a for loop to calculate the product of 'YIELD' and 'NITROGEN'
for (i in 1:nrow(data)) {
data$results[i] <- data$YIELD[i] * data$NITROGEN[i]
}
print(data)
data
View(data)
# Columns to include in the boxplot
columns_to_plot <- c("YIELD", "NITROGEN", "result")
columns_to_plot
# Create a new window for the boxplot
par(mfrow = c(1, length(columns_to_plot)))
# Using a for loop to create boxplots for each column
for (col in columns_to_plot) {
boxplot(data[[col]], main = col, ylab = col)
}
# Columns to include in the boxplot
columns_to_plot <- c("YIELD", "NITROGEN", "results")
columns_to_plot
# Create a new window for the boxplot
par(mfrow = c(1, length(columns_to_plot)))
# Using a for loop to create boxplots for each column
for (col in columns_to_plot) {
boxplot(data[[col]], main = col, ylab = col)
}
## par and mfrow function uses
# Set up a 2x2 layout for multiple plots
par(mfrow = c(2, 2))
# Create and plot some example data
plot(1:10, main = "Plot 1")
plot(1:10, main = "Plot 2")
plot(1:10, main = "Plot 3")
plot(1:10, main = "Plot 4")
## par and mfrow function uses
# Set up a 2x2 layout for multiple plots
par(mfrow = c(1, 2))
# Create and plot some example data
plot(1:10, main = "Plot 1")
plot(1:10, main = "Plot 2")
plot(1:10, main = "Plot 3")
plot(1:10, main = "Plot 4")
## par and mfrow function uses
# Set up a 2x2 layout for multiple plots
par(mfrow = c(1, 3))   ## rows and columns
# Create and plot some example data
plot(1:10, main = "Plot 1")
plot(1:10, main = "Plot 2")
plot(1:10, main = "Plot 3")
plot(1:10, main = "Plot 4")
## par and mfrow function uses
# Set up a 2x2 layout for multiple plots
par(mfrow = c(1, 4))   ## rows and columns
# Create and plot some example data
plot(1:10, main = "Plot 1")
plot(1:10, main = "Plot 2")
plot(1:10, main = "Plot 3")
plot(1:10, main = "Plot 4")
# Columns to include in the boxplot
columns_to_plot <- c("YIELD", "NITROGEN", "results")
columns_to_plot
source("C:/Users/windows/OneDrive/Desktop/loops.R", echo=TRUE)
# Using a for loop to create boxplots for each column
for (col in columns_to_plot) {
boxplot(data[[col]], main = col, ylab = col)  ##col repersents column
}
# Using a for loop to create boxplots for each column
for (col in columns_to_plot) {
boxplot(data[[col]], main = col, ylab = col)  ##col repersents column
}
## par and mfrow function uses
# Set up a 2x2 layout for multiple plots
par(mfrow = c(2, 4))   ## rows and columns
# Using a for loop to create boxplots for each column
for (col in columns_to_plot) {
boxplot(data[[col]], main = col, ylab = col)  ##col repersents column
}
## par and mfrow function uses
# Set up a 2x2 layout for multiple plots
par(mfrow = c(1, 4))   ## rows and columns
# Create and plot some example data
plot(1:10, main = "Plot 1")
plot(1:10, main = "Plot 2")
plot(1:10, main = "Plot 3")
plot(1:10, main = "Plot 4")
# Create a new column 'PRODUCT' to store the results
data$result <- numeric(nrow(data))
# Initialize a counter
counter <- 1
# Using a while loop to calculate the product of 'YIELD' and 'NITROGEN'
while (counter <= nrow(data)) {
data$PRODUCT_WHILE[counter] <- data$YIELD[counter] * data$NITROGEN[counter]
counter <- counter + 1
}
# Using a while loop to calculate the product of 'YIELD' and 'NITROGEN'
while (counter <= nrow(data)) {
data$result[counter] <- data$YIELD[counter] * data$NITROGEN[counter]
counter <- counter + 1
}
# Display the updated dataframe
print(data)
# Create a new column 'PRODUCT' to store the results
data$result <- numeric(nrow(data))
# Initialize a counter
counter <- 1
# Using a while loop to calculate the product of 'YIELD' and 'NITROGEN'
while (counter <= nrow(data)) {
data$result[counter] <- data$YIELD[counter] * data$NITROGEN[counter]
counter <- counter + 1
}
# Display the updated dataframe
print(data)
# Set a seed for reproducibility
set.seed(123)
# Number of markers and individuals
num_markers <- 50
num_individuals <- 20
# Generate SNP data (0, 1, or 2) randomly
snp_data <- matrix(sample(0:2, num_markers * num_individuals, replace = TRUE), nrow = num_individuals, ncol = num_markers)
# Convert the matrix to a data frame for better readability
snp_df <- as.data.frame(snp_data)
# Print the generated SNP data
print(snp_df)
set.seed(123)
# Function to calculate Minor Allele Frequency (MAF)
calculate_maf <- function(genotypes) {
allele_freq <- table(genotypes) / length(genotypes)
maf <- min(allele_freq)
return(maf)
}
maf
set.seed(123)
# Function to calculate Minor Allele Frequency (MAF)
calculate_maf <- function(genotypes) {
allele_freq <- table(genotypes) / length(genotypes)
maf <- min(allele_freq)
return(maf)
}
# Function to calculate heterozygotes
calculate_heterozygotes <- function(genotypes) {
heterozygotes <- sum(genotypes == 1)
return(heterozygotes)
}
# Function to calculate missing value percentage
calculate_missing_percentage <- function(genotypes) {
missing_percentage <- sum(is.na(genotypes)) / length(genotypes) * 100
return(missing_percentage)
}
# Initialize variables to store results
maf_results <- numeric(ncol(snp_df))
heterozygotes_results <- numeric(ncol(snp_df))
missing_percentage_results <- numeric(ncol(snp_df))
# Loop through each column (SNP marker) in the dataframe
for (col in 1:ncol(snp_df)) {
genotypes <- snp_df[, col]
# Calculate MAF
maf_results[col] <- calculate_maf(genotypes)
# Calculate heterozygotes
heterozygotes_results[col] <- calculate_heterozygotes(genotypes)
# Calculate missing value percentage
missing_percentage_results[col] <- calculate_missing_percentage(genotypes)
}
# Display the results
results_df <- data.frame(
Marker = colnames(snp_df),
MAF = maf_results,
Heterozygotes = heterozygotes_results,
MissingPercentage = missing_percentage_results
)
print(results_df)
View(snp_df)
maf <- min(allele_freq)
return(maf)
set.seed(123)
# defining Function to calculate Minor Allele Frequency (MAF)
calculate_maf <- function(genotypes) {
allele_freq <- table(genotypes) / length(genotypes)
maf <- min(allele_freq)
return(maf)
}
# Function to calculate heterozygotes
calculate_heterozygotes <- function(genotypes) {
heterozygotes <- sum(genotypes == 1) / sum(genotypes)
return(heterozygotes)
}
# Function to calculate missing value percentage
calculate_missing_percentage <- function(genotypes) {
missing_percentage <- sum(is.na(genotypes)) / length(genotypes) * 100
return(missing_percentage)
}
# Initialize variables to store results
maf_results <- numeric(ncol(snp_df))
heterozygotes_results <- numeric(ncol(snp_df))
missing_percentage_results <- numeric(ncol(snp_df))
# Loop through each column (SNP marker) in the dataframe
for (col in 1:ncol(snp_df)) {
genotypes <- snp_df[, col]
# Calculate MAF
maf_results[col] <- calculate_maf(genotypes)
# Calculate heterozygotes
heterozygotes_results[col] <- calculate_heterozygotes(genotypes)
# Calculate missing value percentage
missing_percentage_results[col] <- calculate_missing_percentage(genotypes)
}
# Display the results
results_df <- data.frame(
Marker = colnames(snp_df),
MAF = maf_results,
Heterozygotes = heterozygotes_results,
MissingPercentage = missing_percentage_results
)
print(results_df)
library(lme4)
library(lme4)
glm.mod <- glm(
sex ~ body_mass_g + bill_length_mm + species,
family = binomial,
data = penguins_data
)
install.packages("palmerpenguins")
library(palmerpenguins)
library(lme4)
glm.mod <- glm(
sex ~ body_mass_g + bill_length_mm + species,
family = binomial,
data = penguins_data
)
source("~/.active-rstudio-document", echo=TRUE)
install.packages("palmerpenguins")
library(palmerpenguins)
library(lme4)
data("penguins")
force(penguins)
force(penguins_raw)
View(penguins_raw)
View(penguins_raw)
data("penguins")
penguins_data <- penguins
glm.mod <- glm(
sex ~ body_mass_g + bill_length_mm + species,
family = binomial,
data = penguins_data
)
View(penguins)
View(glm.mod)
##fitted.values contains the probabilities the GLM predicted
glm.mod$fitted.values[1:10]
threshold <- 0.5
preds <- penguins_data %>%
mutate(
prob.fit = glm.mod$fitted.values,
prediction = if_else(prob.fit > threshold, 'male', 'female'),
correct = if_else(sex == prediction, 'correct', 'incorrect')
)
library(tidyverse)
threshold <- 0.5
preds <- penguins_data %>%
mutate(
prob.fit = glm.mod$fitted.values,
prediction = if_else(prob.fit > threshold, 'male', 'female'),
correct = if_else(sex == prediction, 'correct', 'incorrect')
)
preds
threshold <- 0.5
preds <- penguins_data %>%
mutate(
prob.fit = glm.mod$fitted.values,
prediction = if_else(prob.fit > threshold, 'male', 'female'),
correct = if_else(sex == prediction, 'correct', 'incorrect')
)
##fitted.values contains the probabilities the GLM predicted
glm.mod$fitted.values[1:10]
dim(glm.mod$fitted.values)
##fitted.values contains the probabilities the GLM predicted
glm.mod$fitted.values[1:10]
dim(glm.mod$fitted.values)
length(glm.mod$fitted.values)
threshold <- 0.5
preds <- penguins_data %>%
mutate(
prob.fit = glm.mod$fitted.values,
prediction = if_else(prob.fit > threshold, 'male', 'female'),
correct = if_else(sex == prediction, 'correct', 'incorrect')
)
##manually turn the predicted probabilities into sex predictions.
##That requires us to know whether the predicted
##probability refers to male or female penguins.
any(is.na(glm.mod$fitted.values))
head(penguins_data)
head(glm.mod$fitted.values)
dim(penguins_data)
penguins_data <- na.omit(penguins_data)
## fit the glm model from the glm function of lme4 Package
glm.mod <- glm(
sex ~ body_mass_g + bill_length_mm + species,
family = binomial,
data = penguins_data
)
##fitted.values contains the probabilities the GLM predicted
glm.mod$fitted.values[1:10]
length(glm.mod$fitted.values)
##manually turn the predicted probabilities into sex predictions.
##That requires us to know whether the predicted
##probability refers to male or female penguins.
any(is.na(glm.mod$fitted.values))
head(penguins_data)
head(glm.mod$fitted.values)
dim(penguins_data)
threshold <- 0.5
preds <- penguins_data %>%
mutate(
prob.fit = glm.mod$fitted.values,
prediction = if_else(prob.fit > threshold, 'male', 'female'),
correct = if_else(sex == prediction, 'correct', 'incorrect')
)
preds
new_observations <- tibble(
body_mass_g = c(4532, 5392),
bill_length_mm = c(40, 49),
species = c('Adelie', 'Gentoo')
)
predict(
glm.mod,
newdata = new_observations
)
predict(
glm.mod,
newdata = new_observations,
type = 'response'
)
new_observations |>
mutate(
pred_prob = predict(
glm.mod,
newdata = new_observations,
type = 'response'
)
)
new_observations |>
mutate(
pred_prob = predict(
glm.mod,
newdata = new_observations,
type = 'response',
prediction = if_else(prob.fit > threshold, 'male', 'female'),
correct = if_else(sex == prediction, 'correct', 'incorrect')
)
)
new_observations
new_observations |>
mutate(
pred_prob = predict(
glm.mod,
newdata = new_observations,
type = 'response',
prediction = if_else(prob.fit > threshold, 'male', 'female'),
correct = if_else(sex == prediction, 'correct', 'incorrect')
)
)
new_observations >%>
new_observations1 <- new_observations %>%
mutate(
pred_prob = predict(glm.mod, newdata = new_observations, type = 'response'),
prediction = if_else(pred_prob > threshold, 'male', 'female'),
correct = if_else(sex == prediction, 'correct', 'incorrect')
)
new_observations %>%
mutate(
pred_prob = predict(
glm.mod,
newdata = .,
type = 'response'
)
)
new_observations %>%
mutate(
pred_prob = predict(
glm.mod,
newdata = new_observations,
type = 'response'
)
)
new_observations %>%
mutate(
pred_prob = predict(
glm.mod,
newdata = new_observations,
prediction = if_else(prob.fit > threshold, 'male', 'female'),
type = 'response'
)
)
new_observations <- new_observations %>%
mutate(
pred_prob = predict(
glm.mod,
newdata = new_observations,
type = 'response'
),
prediction = if_else(pred_prob > 0.5, 'male', 'female')
)
new_observations
View(penguins_data)
setwd("C:/Users/windows/OneDrive/Desktop/mixed models/GLM")
write.csv(penguins_data, "penguins_data.csv")
